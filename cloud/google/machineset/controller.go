// This file was autogenerated by apiregister-gen. Do not edit it manually!

package machineset

import (
	"fmt"
	"strings"
	"time"

	"github.com/golang/glog"
	"github.com/kubernetes-incubator/apiserver-builder/pkg/builders"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	clusterv1 "sigs.k8s.io/cluster-api/pkg/apis/cluster/v1alpha1"
	"sigs.k8s.io/cluster-api/pkg/client/clientset_generated/clientset"
	listers "sigs.k8s.io/cluster-api/pkg/client/listers_generated/cluster/v1alpha1"
	"sigs.k8s.io/cluster-api/pkg/controller/sharedinformers"
	"sigs.k8s.io/cluster-api/pkg/util"
)

// Finalizer is set on PreareForCreate callback
const MachineSetFinalizer string = "machineset.cluster.k8s.io"

// controllerKind contains the schema.GroupVersionKind for this controller type.
var controllerKind = clusterv1.SchemeGroupVersion.WithKind("MachineSet")

// +controller:group=cluster,version=v1alpha1,kind=MachineSet,resource=machinesets
type MachineSetControllerImpl struct {
	builders.DefaultControllerFns
	clientSet clientset.Interface
	// machineSetsLister indexes properties about MachineSet
	machineSetsLister listers.MachineSetLister
	// machineLister holds a lister that knows how to list Machines from a cache
	machineLister listers.MachineLister
	actuator      SetActuator
}

// Init initializes the controller and is called by the generated code
// Register watches for additional resource types here.
func (c *MachineSetControllerImpl) Init(arguments sharedinformers.ControllerInitArguments, actuator SetActuator) {
	c.machineSetsLister = arguments.GetSharedInformers().Factory.Cluster().V1alpha1().MachineSets().Lister()
	c.machineLister = arguments.GetSharedInformers().Factory.Cluster().V1alpha1().Machines().Lister()
	var err error
	c.clientSet, err = clientset.NewForConfig(arguments.GetRestConfig())
	if err != nil {
		glog.Fatalf("error building clientset for machineClient: %v", err)
	}
	c.actuator = actuator
}

// Reconcile holds the controller's business logic.
// it makes sure that the current state is equal to the desired state.
// note that the current state of the cluster is calculated based on the number of machines
// that are owned by the given machineSet (key).
func (c *MachineSetControllerImpl) Reconcile(machineSet *clusterv1.MachineSet) error {
	glog.Infof("Running reconcile MachineSet for %s", machineSet.Name)
	if !machineSet.DeletionTimestamp.IsZero() {
		return c.delete(machineSet)
	}
	var err error
	if !util.Contains(machineSet.Finalizers, MachineSetFinalizer) {
		machineSet.Finalizers = append(machineSet.Finalizers, MachineSetFinalizer)
		machineSet, err = c.clientSet.ClusterV1alpha1().MachineSets(machineSet.Namespace).Update(machineSet)
		if err != nil {
			glog.Errorf("Error adding finalizer to machine set object %v: %v", machineSet.Name, err)
			return err
		}
	}
	filteredMachines, err := c.getMachines(machineSet)
	if err != nil {
		return err
	}
	return c.syncReplicas(machineSet, filteredMachines)
}
func (c *MachineSetControllerImpl) Get(namespace, name string) (*clusterv1.MachineSet, error) {
	return c.machineSetsLister.MachineSets(namespace).Get(name)
}

// syncReplicas essentially scales machine resources up and down.
func (c *MachineSetControllerImpl) syncReplicas(machineSet *clusterv1.MachineSet, machines []*clusterv1.Machine) error {
	// Take ownership of machines if not already owned.
	for _, machine := range machines {
		if shouldAdopt(machineSet, machine) {
			c.adoptOrphan(machineSet, machine)
		}
	}
	start := time.Now()
	verb := "Resizing"
	var size string
	exist, err := c.actuator.GroupExists(machineSet)
	if err != nil {
		glog.Errorf("Error checking existence of IGM for machine set [%v]: %v", machineSet.Name, err)
		// TODO(janluk): Ignore this error for now
		// return err
	}
	if !exist {
		glog.Infof("IGM for machine set [%v] does not exist. Creating one.", machineSet.Name)
		if err := c.actuator.CreateGroup(machineSet); err != nil {
			glog.Errorf("Failed to create IGM: %v", err)
		}
		verb = "Creating"
		size = fmt.Sprintf("size = %d", *machineSet.Spec.Replicas)
	}
	vms, err := c.actuator.ListMachines(machineSet)
	if err != nil {
		glog.Errorf("Error listing machines for machine set %v", machineSet.Name)
		return err
	}
	diff := *machineSet.Spec.Replicas - int32(len(vms))
	if diff != 0 {
		if err := c.actuator.ResizeGroup(machineSet); err != nil {
			glog.Errorf("Error resizing machine set %v", machineSet.Name)
			return nil
		}
		vms, err = c.actuator.ListMachines(machineSet)
		if err != nil {
			glog.Errorf("Error listing machines for machine set %v after resize", machineSet.Name)
			return err
		}
		size = fmt.Sprintf("new size = %d, diff = %d", *machineSet.Spec.Replicas, diff)
	}
	existingMachines := make(map[string]bool)
	for _, m := range machines {
		existingMachines[m.Name] = true
	}
	existingVms := make(map[string]bool)
	for _, vm := range vms {
		parts := strings.Split(vm, "/")
		vm = parts[len(parts)-1]
		existingVms[vm] = true
		if !existingMachines[vm] {
			if _, err := c.createMachine(machineSet, vm); err != nil {
				glog.Errorf("unable to create a machine = %s, due to %v", vm, err)
				return err
			}
		}
	}
	for _, m := range machines {
		if !existingVms[m.Name] {
			if err := c.deleteMachine(machineSet, m); err != nil {
				glog.Errorf("unable to delete a machine = %s, due to %v", m.Name, err)
				return err
			}
		}
	}
	machineSet.Status.Replicas = *machineSet.Spec.Replicas
	_, err = c.updateStatus(machineSet)
	glog.Infof("%v of machine (%v) took %v", verb, size, time.Since(start))
	return err
}

// createMachine creates a machine resource.
// the name of the newly created resource is going to be created by the API server, we set the generateName field
func (c *MachineSetControllerImpl) createMachine(machineSet *clusterv1.MachineSet, name string) (*clusterv1.Machine, error) {
	gv := clusterv1.SchemeGroupVersion
	machine := &clusterv1.Machine{
		TypeMeta: metav1.TypeMeta{
			Kind:       gv.WithKind("Machine").Kind,
			APIVersion: gv.String(),
		},
		ObjectMeta: machineSet.Spec.Template.ObjectMeta,
		Spec:       machineSet.Spec.Template.Spec,
	}
	machine.ObjectMeta.Name = name
	machine.ObjectMeta.OwnerReferences = []metav1.OwnerReference{*metav1.NewControllerRef(machineSet, controllerKind)}
	return c.clientSet.ClusterV1alpha1().Machines(machineSet.Namespace).Create(machine)
}
func (c *MachineSetControllerImpl) deleteMachine(machineSet *clusterv1.MachineSet, machine *clusterv1.Machine) error {
	machine.ObjectMeta.Finalizers = util.Filter(machine.ObjectMeta.Finalizers, clusterv1.MachineFinalizer)
	machine, err := c.clientSet.ClusterV1alpha1().Machines(machineSet.Namespace).Update(machine)
	if err != nil {
		glog.Errorf("Error removing finalizer from machine object %v; %v", machine.Name, err)
		return err
	}
	return c.clientSet.ClusterV1alpha1().Machines(machineSet.Namespace).Delete(machine.Name, &metav1.DeleteOptions{})
}

// getMachines returns a list of machines that match on machineSet.Spec.Selector
func (c *MachineSetControllerImpl) getMachines(machineSet *clusterv1.MachineSet) ([]*clusterv1.Machine, error) {
	selector, err := metav1.LabelSelectorAsSelector(&machineSet.Spec.Selector)
	if err != nil {
		return nil, err
	}
	filteredMachines, err := c.machineLister.List(selector)
	if err != nil {
		return nil, err
	}
	return filteredMachines, err
}
func shouldAdopt(machineSet *clusterv1.MachineSet, machine *clusterv1.Machine) bool {
	// Do nothing if the machine is being deleted.
	if !machine.ObjectMeta.DeletionTimestamp.IsZero() {
		glog.V(2).Infof("Skipping machine (%v), as it is being deleted.", machine.Name)
		return false
	}
	// Machine owned by another controller.
	if metav1.GetControllerOf(machine) != nil && !metav1.IsControlledBy(machine, machineSet) {
		glog.Warningf("Skipping machine (%v), as it is owned by someone else.", machine.Name)
		return false
	}
	// Machine we control.
	if metav1.IsControlledBy(machine, machineSet) {
		return false
	}
	return true
}
func (c *MachineSetControllerImpl) adoptOrphan(machineSet *clusterv1.MachineSet, machine *clusterv1.Machine) {
	// Add controller reference.
	ownerRefs := machine.ObjectMeta.GetOwnerReferences()
	if ownerRefs == nil {
		ownerRefs = []metav1.OwnerReference{}
	}
	newRef := *metav1.NewControllerRef(machineSet, controllerKind)
	ownerRefs = append(ownerRefs, newRef)
	machine.ObjectMeta.SetOwnerReferences(ownerRefs)
	if _, err := c.clientSet.ClusterV1alpha1().Machines(machineSet.Namespace).Update(machine); err != nil {
		glog.Warningf("Failed to update machine owner reference. %v", err)
	}
}
func (c *MachineSetControllerImpl) delete(machineSet *clusterv1.MachineSet) error {
	if !util.Contains(machineSet.Finalizers, MachineSetFinalizer) {
		glog.Infof("Reconciling machines set object %v causes a no-op as there is no finalizer.", machineSet.Name)
		return nil
	}
	glog.Infof("Reconciling machine set object %v triggers delete.", machineSet.Name)
	if err := c.actuator.DeleteGroup(machineSet); err != nil {
		glog.Errorf("Error deleting IGM %v: %v", machineSet.Name, err)
		return err
	}
	glog.Infof("Machines set object %v deletion successful, removing finalizer.", machineSet.Name)
	machineSet.Finalizers = util.Filter(machineSet.Finalizers, MachineSetFinalizer)
	if _, err := c.clientSet.ClusterV1alpha1().MachineSets(machineSet.Namespace).Update(machineSet); err != nil {
		glog.Errorf("Error removing finalizer from machine object %v: %v", machineSet.Name, err)
		return err
	}
	return nil
}
func (c *MachineSetControllerImpl) updateStatus(machineSet *clusterv1.MachineSet) (*clusterv1.MachineSet, error) {
	ms, err := c.clientSet.ClusterV1alpha1().MachineSets(machineSet.Namespace).UpdateStatus(machineSet)
	if err != nil {
		glog.Errorf("Error updating machine set replicas: %v", err)
		return nil, err
	}
	return ms, nil
}
